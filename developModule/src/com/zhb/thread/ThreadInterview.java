package com.zhb.thread;

/**
 * @author zhb
 * @create 2022-02-07 5:00
 */
/*
java中有几种方法可以实现一个线程(jdk5.0之前)？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
答：有两种实现方法，分别是继承Thread类与实现Runnable接口。
用synchronized关键字修饰同步方法，反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。
suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，
指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

sleep() 和 wait() 有什么区别?
答：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

同步和异步有何异同，在什么情况下分别使用他们？举例说明。
答：如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

启动一个线程是用run()还是start()?
答：启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法就是正常的对象调用方法的执行，并不是使用分线程来执行的。

当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
答：不能，一个对象的一个synchronized方法只能由一个线程访问。

多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?
答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口
同步的实现方面有两种，分别是synchronized,wait与notify

线程的基本概念、线程的基本状态以及状态之间的关系
答：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。
Java中的线程有四种状态分别是：创建、就绪、运行、阻塞、结束
简述synchronized和java.util.concurrent.locks.Lock的异同 ？
答：主要相同点：Lock能完成synchronized所实现的所有功能
主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。

C 是单线程语言。

在 Java 中，高优先级的可运行线程会抢占低优先级线程。

4.程序开发者必须创建一个线程去管理内存的分配。（ ）答案：错误
知识点：Java 提供了一个系统线程来管理内存的分配。

5.一个线程在调用它的 start 方法，之前，该线程将一直处于出生期。（ ）
6.当调用一个正在进行线程的 stop()方法时，该线程便会进入休眠状态。（ ）
7.如果线程的 run 方法执行结束或抛出一个不能捕获的例外，线程便进入等待状态。（ ）
8.一个线程可以调用 yield 方法使其他线程有机会运行。（ ）

5.难度：容易
答案：正确
知识点：出生期的概念。
6.难度：适中
答案：错误
知识点：应该是 sleep 方法。
7.难度：适中
答案：错误
知识点：如果线程的 run 方法执行结束或抛出一个不能捕获的例外，线程便进入死亡状态。
8.难度：适中
答案：正确
知识点：yield 方法总是让高优先级的就绪线程先运行。

知识点：一个线程被用 suspend( )方法，将该线程挂起。并通过调用 resume( )方法来重新开始线程的执行。
但是该方法容易导致死锁，应尽量避免使用。

8.▁▁方法可以用来暂时停止当前线程的运行。
A stop( )
B sleep( )
C wait( )
D suspend()
8.难度：适中
答案：BCD

Java为什么要引入线程机制，线程、程序、进程之间的关系是怎样的。

答：线程可以彼此独立的执行，它是一种实现并发机制的有效手段，可以同时使用多个线程来完成不同的任务，并且一般用户在使用多线程时并不考虑底层处理的细节。
程序是一段静态的代码，是软件执行的蓝本。进程是程序的一次动态执行过程，即是处于运行过程中的程序。
线程是比进程更小的程序执行单位，一个进程可以启动多个线程同时运行，不同线程之间可以共享相同的内存区域和数据。多线程程序是运行时间后嗣可能出现在一个进程之内的、有一个以上线程同时运行的情况的程序。

Runnable接口包括哪些抽象方法？Thread类有哪些主要域和方法？

答：Runnable接口中仅有run()抽象方法。
Thread类主要域有：MAX_PRIORITY,MIN_PRIORITY,NORM_PRIORITY。
主要方法有start(),run(),sleep(),currentThread(),setPriority(),getPriority(),join()等。

创建线程有哪两种方式(jdk5.0之前)？试写出每种的具体的流程。比较两种创建方式的不同，哪个更优。

1—继承Thread类
1)  定义类继承Thread类。
2)  覆盖Thread类中的run方法。
3)  创建Thread子类对象，即创建了线程对象。
4)  调用线程对象start方法：启动线程，调用run方法。

2—实现Runnable接口
1）定义类，实现Runnable接口。
2）覆盖Runnable接口中的run方法。
3）通过Thread类建立线程对象。
4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。
5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。

【区别】
继承Thread: 线程代码存放Thread子类run方法中。
实现Runnable：线程代码存在接口的子类的run方法。

【实现方法的好处】
1）避免了单继承的局限性
2）多个线程可以共享同一个接口子类的对象，非常适合多个相同线程来处理同一份资源。

 */
//   在{1}添加什么代码，可以保证如下代码输出100
//      提示：t.wait()  或  t.join()  或 t.yield() 或  t.interrupt()？
class Test {//答案：t.join()
    public static void main(String[] args) {
        MyThread m = new MyThread();
        Thread t = new Thread(m);
        t.start();

        //{1}

        int j = m.i;
        System.out.println(j);
    }
}
class MyThread implements Runnable{
    int i;
    public void run(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        i=100;
    }
}

public class ThreadInterview {
}
